<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hairstyle Matcher (Colab backend)</title>
<style>
  :root{--bg:#eef5ff;--bg2:#f8fbff;--card:#fff;--muted:#6b7280;--text:#1f2937;--primary:#2b6cb0;--border:#dbe3f0;--shadow:0 16px 40px rgba(16,42,87,.12);--radius:18px}
  *{box-sizing:border-box} html,body{height:100%} body{margin:0;font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:var(--text);
  background:radial-gradient(1200px 600px at -10% -10%, rgba(122,168,255,.25), transparent), linear-gradient(135deg, var(--bg) 0%, var(--bg2) 70%, #fff 100%)}
  .wrap{max-width:1100px;margin:0 auto;padding:28px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);padding:20px}
  .grid{display:grid;grid-template-columns:1.2fr 1fr;gap:22px} @media(max-width:980px){.grid{grid-template-columns:1fr}}
  .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:12px;background:var(--primary);color:#fff;border:none;cursor:pointer;font-weight:600}
  .btn.secondary{background:#eef4ff;color:#274472}
  .uploader{border:2px dashed #c9d7f0;border-radius:16px;padding:20px;text-align:center;background:linear-gradient(180deg,#fff,#f7fbff)}
  .uploader input{display:none}
  .preview{margin-top:14px;display:flex;gap:14px;flex-wrap:wrap}
  .preview img{max-width:240px;max-height:240px;object-fit:cover;border-radius:14px;border:1px solid var(--border)}
  .result{display:none;margin-top:14px;border:1px dashed #d7e4ff;border-radius:14px;padding:14px;background:linear-gradient(180deg,#fff,#f7fbff)}
  .result.show{display:block}
  .skeleton{width:100%;aspect-ratio:4/5;border-radius:10px;background:linear-gradient(90deg,#eef2f7 0%,#f7f9fc 50%,#eef2f7 100%);background-size:200% 100%;animation:sk 1.2s infinite linear}
  @keyframes sk{0%{background-position:200% 0}100%{background-position:-200% 0}}
  .match-grid{display:grid;grid-template-columns:1fr 1fr;gap:14px;margin-top:10px} @media(max-width:720px){.match-grid{grid-template-columns:1fr}}
  .match-card{border:1px solid var(--border);border-radius:12px;padding:12px;background:#fff}
  .match-card img{width:100%;aspect-ratio:4/5;object-fit:cover;border-radius:10px;border:1px solid #edf1f7}
  .muted{color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <h1>Hairstyle Matcher (Colab backend)</h1>

  <div class="grid">
    <section class="card">
      <h2>Upload</h2>
      <div class="uploader" id="dropzone">
        <p><strong>Drag & drop</strong> or</p>
        <label class="btn"><input id="fileInput" type="file" accept="image/*">Choose a Photo</label>
        <div class="muted" style="font-size:13px;margin-top:6px">Image is processed locally; only sent to backend when you click Generate.</div>
        <div class="preview" id="preview"></div>
      </div>

      <div style="margin-top:14px;display:flex;gap:10px;align-items:center;flex-wrap:wrap">
        <button class="btn" id="genBtn">Generate (AI)</button>
        <button class="btn secondary" id="resetBtn">Reset</button>
        <span class="muted" id="statusText"></span>
      </div>

      <div id="result" class="result" aria-live="polite">
        <div class="match-grid">
          <div class="match-card">
            <div class="muted" style="margin-bottom:6px">Your Photo</div>
            <img id="yourPhoto" alt="Your photo">
          </div>
          <div class="match-card">
            <div class="muted" style="margin-bottom:6px">AI Result</div>
            <div id="styleSkeleton" class="skeleton" style="display:none"></div>
            <img id="stylePhoto" alt="Suggested hairstyle" style="display:none">
          </div>
        </div>
      </div>
    </section>

    <aside class="card">
      <h2>How it connects</h2>
      <ol>
        <li>This page POSTs to your <strong>Colab FastAPI</strong> exposed via Cloudflare Tunnel.</li>
        <li>Backend may return the image immediately or a job <code>id</code> to poll.</li>
        <li>Supports <code>image_url</code> or <code>image_b64</code>. If CSP blocks <code>data:</code>, we convert to <code>blob:</code>.</li>
      </ol>
      <p class="muted">If you see “Failed to fetch”, verify the tunnel URL is correct and Colab server is still running.</p>
    </aside>
  </div>
</div>

<script>
/* ---------- 0) Configure this to your current Cloudflare Tunnel URL ---------- */
const AI_BACKEND_ENDPOINT = 'https://medal-zus-test-organization.trycloudflare.com'; // ← replace when your tunnel changes
const REQUEST_TIMEOUT_MS = 180000;       // allow long gens
const POLL_INTERVAL_MS   = 1500;

/* ---------- 1) UI refs ---------- */
const fileInput  = document.getElementById('fileInput');
const dropzone   = document.getElementById('dropzone');
const preview    = document.getElementById('preview');
const genBtn     = document.getElementById('genBtn');
const resetBtn   = document.getElementById('resetBtn');
const resultBox  = document.getElementById('result');
const yourPhoto  = document.getElementById('yourPhoto');
const stylePhoto = document.getElementById('stylePhoto');
const styleSkel  = document.getElementById('styleSkeleton');
const statusText = document.getElementById('statusText');

/* ---------- 2) Helpers ---------- */
function dataURLtoObjectURL(dataURL){
  const [meta,b64] = dataURL.split(',');
  const m = /data:(.*?);base64/.exec(meta);
  const mime = m ? m[1] : 'image/png';
  const bin = atob(b64);
  const buf = new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) buf[i] = bin.charCodeAt(i);
  const blob = new Blob([buf], {type:mime});
  return URL.createObjectURL(blob);
}

async function downscale(dataURL, maxW=1280, maxH=1280){
  return new Promise((resolve, reject)=>{
    const img = new Image();
    img.onload = ()=>{
      const r = Math.min(maxW/img.width, maxH/img.height, 1);
      const w = Math.round(img.width*r), h = Math.round(img.height*r);
      const c = document.createElement('canvas'); c.width=w; c.height=h;
      const ctx = c.getContext('2d');
      ctx.drawImage(img, 0, 0, w, h);
      resolve(c.toDataURL('image/png'));
    };
    img.onerror = ()=>reject(new Error('Decode failed'));
    img.src = dataURL;
  });
}

async function safeFetch(url, opts){
  try { return await fetch(url, opts); }
  catch { throw new Error('Failed to fetch'); }
}

/* ---------- 3) Uploader ---------- */
['dragenter','dragover'].forEach(evt=>{
  dropzone.addEventListener(evt, e=>{e.preventDefault(); dropzone.classList.add('drag');});
});
['dragleave','drop'].forEach(evt=>{
  dropzone.addEventListener(evt, e=>{e.preventDefault(); dropzone.classList.remove('drag');});
});
dropzone.addEventListener('drop', e=>{
  const f = e.dataTransfer.files?.[0]; if (f) handleFile(f);
});
fileInput.addEventListener('change', e=>{
  const f = e.target.files?.[0]; if (f) handleFile(f);
});

function handleFile(file){
  if (!file || !file.type.startsWith('image/')) return;
  const reader = new FileReader();
  reader.onload = e=>{
    const url = e.target.result;
    preview.innerHTML = `<img src="${url}" alt="preview">`;
    yourPhoto.src = url;
    resultBox.classList.remove('show');
  };
  reader.readAsDataURL(file);
}

/* ---------- 4) Main flow ---------- */
genBtn.addEventListener('click', async ()=>{
  if (!yourPhoto.src) { alert('Please choose a photo first.'); return; }
  statusText.textContent = 'Preparing...';
  stylePhoto.style.display='none'; styleSkel.style.display='block';
  resultBox.classList.add('show');

  try{
    // downscale + send
    const png = await downscale(yourPhoto.src, 1280, 1280);
    const b64 = png.split(',')[1];

    const create = await safeFetch(`${AI_BACKEND_ENDPOINT}/create`, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({
        // You can add extra controls your FastAPI supports:
        prompt: 'Add a clean, professional medium hairstyle that fits a round/square face; keep same identity.',
        image_base64: b64
      })
    });

    if (!create.ok) throw new Error(await create.text());

    const cj = await create.json();

    // Case A: backend returns image right away
    if (cj.image_url || cj.image_b64) {
      await showImageFromResponse(cj);
      return;
    }

    // Case B: backend returns a job id → poll
    if (!cj.id) throw new Error('No id returned from backend.');
    statusText.textContent = 'Generating...';

    const started = Date.now();
    while (true) {
      const r = await safeFetch(`${AI_BACKEND_ENDPOINT}/status/${cj.id}`);
      if (!r.ok) throw new Error(await r.text());
      const s = await r.json();

      if (s.status === 'succeeded') {
        await showImageFromResponse(s);
        break;
      }
      if (s.error) throw new Error(s.error);

      if (Date.now() - started > REQUEST_TIMEOUT_MS) throw new Error('Timeout');
      await new Promise(res=>setTimeout(res, POLL_INTERVAL_MS));
    }
  } catch (e) {
    console.error(e);
    alert('AI error: ' + e.message);
    statusText.textContent = 'Error';
  } finally {
    styleSkel.style.display='none';
  }
});

resetBtn.addEventListener('click', ()=>{
  fileInput.value=''; preview.innerHTML=''; yourPhoto.removeAttribute('src');
  stylePhoto.removeAttribute('src'); stylePhoto.style.display='none';
  statusText.textContent = '';
  resultBox.classList.remove('show');
});

/* ---------- 5) Render helper ---------- */
async function showImageFromResponse(obj){
  if (obj.image_url) {
    stylePhoto.src = obj.image_url;
  } else if (obj.image_b64) {
    // If CSP blocks data:, convert to blob:
    const url = obj.image_b64.startsWith('data:') ? dataURLtoObjectURL(obj.image_b64) : obj.image_b64;
    stylePhoto.src = url;
  } else {
    throw new Error('No image in response');
  }
  stylePhoto.style.display='block';
  statusText.textContent = 'Done';
}
</script>
</body>
</html>
